{
  "description": "Core Xala PM hooks for automatic agent routing, SOLID principles, and quality enforcement",
  "hooks": {
    "SessionStart": [
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "CRITICAL RULES: 1) NO emojis in code, comments, commits, or documentation. 2) NO AI tone ('built with love', 'happy coding', 'awesome', 'let's dive in'). 3) Professional, human-written, technical language only. 4) SOLID principles - functions ≤30 lines, files ≤300 lines. 5) Use Conventional Commits (feat:, fix:, docs:). Read xalapm-core/CLAUDE.md for agent routing. Follow xalapm-core/standards/QUALITY_STANDARDS.md."
          }
        ]
      }
    ],
    "PreToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "prompt",
            "prompt": "BEFORE writing code, verify SOLID compliance: 1) Single Responsibility - does this do ONE thing? 2) Is the function ≤30 lines? Is the file ≤300 lines? 3) Can common logic be extracted to shared utilities? 4) Are dependencies injected, not hardcoded? 5) Is there duplication that should be a reusable component? If the code is too long or does too much, SPLIT IT FIRST."
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Write",
        "hooks": [
          {
            "type": "prompt",
            "prompt": "AFTER writing, verify: 1) NO emojis anywhere in the file. 2) NO AI tone in comments/docs. 3) Professional language only. 4) SOLID - function ≤30, file ≤300, class ≤200 lines? 5) JSDoc on exports (professional, no emojis)? 6) Commit message uses Conventional Commits format (feat:, fix:, etc.). If emojis or AI tone detected, REMOVE immediately."
          }
        ]
      }
    ],
    "UserPromptSubmit": [
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "Analyze request for: 1) Agent routing (file types, keywords), 2) SOLID opportunity - can this be built with small, reusable components? 3) Existing utilities to reuse. Always prefer composition over large implementations. Break complex features into small, focused modules before coding."
          }
        ]
      }
    ]
  }
}
